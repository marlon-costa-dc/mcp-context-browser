//! Chunk repository implementation using vector stores

use crate::core::error::{Error, Result};
use crate::core::types::{CodeChunk, Embedding};
use crate::providers::{EmbeddingProvider, VectorStoreProvider};
use crate::repository::{ChunkRepository, RepositoryStats};
use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::Arc;

/// Repository implementation using vector stores for chunk storage
pub struct VectorStoreChunkRepository<E, V>
where
    E: EmbeddingProvider + Send + Sync,
    V: VectorStoreProvider + Send + Sync,
{
    embedding_provider: Arc<E>,
    vector_store_provider: Arc<V>,
    collection_prefix: String,
}

impl<E, V> VectorStoreChunkRepository<E, V>
where
    E: EmbeddingProvider + Send + Sync,
    V: VectorStoreProvider + Send + Sync,
{
    /// Create a new vector store chunk repository
    pub fn new(
        embedding_provider: Arc<E>,
        vector_store_provider: Arc<V>,
    ) -> Self {
        Self {
            embedding_provider,
            vector_store_provider,
            collection_prefix: "chunks_".to_string(),
        }
    }

    /// Get the full collection name with prefix
    fn collection_name(&self, collection: &str) -> String {
        format!("{}{}", self.collection_prefix, collection)
    }
}

#[async_trait]
impl<E, V> ChunkRepository for VectorStoreChunkRepository<E, V>
where
    E: EmbeddingProvider + Send + Sync,
    V: VectorStoreProvider + Send + Sync,
{
    async fn save(&self, chunk: &CodeChunk) -> Result<String> {
        let chunks = vec![chunk.clone()];
        let ids = self.save_batch(&chunks).await?;
        ids.into_iter().next().ok_or_else(|| {
            Error::internal("Failed to save chunk - no ID returned")
        })
    }

    async fn save_batch(&self, chunks: &[CodeChunk]) -> Result<Vec<String>> {
        if chunks.is_empty() {
            return Ok(vec![]);
        }

        let collection = "default"; // For now, use default collection
        let collection_name = self.collection_name(collection);

        // Generate embeddings for all chunks
        let texts: Vec<String> = chunks.iter().map(|c| c.content.clone()).collect();
        let embeddings = self.embedding_provider.embed_batch(&texts).await?;

        // Prepare metadata for each chunk
        let metadata: Vec<HashMap<String, serde_json::Value>> = chunks
            .iter()
            .map(|chunk| {
                let mut meta = HashMap::new();
                meta.insert("content".to_string(), serde_json::json!(chunk.content));
                meta.insert("file_path".to_string(), serde_json::json!(chunk.file_path));
                meta.insert("start_line".to_string(), serde_json::json!(chunk.start_line));
                meta.insert("end_line".to_string(), serde_json::json!(chunk.end_line));
                meta.insert("language".to_string(), serde_json::json!(format!("{:?}", chunk.language)));
                meta.insert("chunk_type".to_string(), serde_json::json!("code_chunk"));
                meta
            })
            .collect();

        // Ensure collection exists
        if !self.vector_store_provider.collection_exists(&collection_name).await? {
            self.vector_store_provider
                .create_collection(&collection_name, self.embedding_provider.dimensions())
                .await?;
        }

        // Store in vector database
        let ids = self.vector_store_provider
            .insert_vectors(&collection_name, &embeddings, metadata)
            .await?;

        Ok(ids)
    }

    async fn find_by_id(&self, id: &str) -> Result<Option<CodeChunk>> {
        // Note: Vector stores typically don't support finding by ID directly
        // This would require maintaining a separate index or using metadata filtering
        // For now, return None as this operation is not efficiently supported
        Ok(None)
    }

    async fn find_by_collection(&self, collection: &str, limit: usize) -> Result<Vec<CodeChunk>> {
        let collection_name = self.collection_name(collection);

        // Search with a zero vector to get all chunks (not ideal but works for small datasets)
        let zero_vector = vec![0.0; self.embedding_provider.dimensions()];
        let search_results = self.vector_store_provider
            .search_similar(&collection_name, &zero_vector, limit, Some("chunk_type:\"code_chunk\""))
            .await?;

        // Convert search results back to code chunks
        let chunks = search_results
            .into_iter()
            .filter_map(|result| {
                // Extract metadata to reconstruct CodeChunk
                if let (Some(content), Some(file_path), Some(start_line), Some(end_line), Some(language_str)) = (
                    result.metadata.get("content").and_then(|v| v.as_str()),
                    result.metadata.get("file_path").and_then(|v| v.as_str()),
                    result.metadata.get("start_line").and_then(|v| v.as_u64()),
                    result.metadata.get("end_line").and_then(|v| v.as_u64()),
                    result.metadata.get("language").and_then(|v| v.as_str()),
                ) {
                    // Parse language (simplified)
                    let language = match language_str {
                        "Rust" => crate::core::types::Language::Rust,
                        "Python" => crate::core::types::Language::Python,
                        "JavaScript" => crate::core::types::Language::JavaScript,
                        "TypeScript" => crate::core::types::Language::TypeScript,
                        _ => crate::core::types::Language::Unknown,
                    };

                    Some(CodeChunk {
                        content: content.to_string(),
                        file_path: file_path.to_string(),
                        start_line: start_line as u32,
                        end_line: end_line as u32,
                        language,
                    })
                } else {
                    None
                }
            })
            .collect();

        Ok(chunks)
    }

    async fn delete(&self, id: &str) -> Result<()> {
        // Note: This is a simplified implementation
        // In practice, you'd need to track IDs and map them to vector store IDs
        // For now, this operation is not fully supported
        Err(Error::not_implemented("Delete by ID not implemented for vector store repository"))
    }

    async fn delete_collection(&self, collection: &str) -> Result<()> {
        let collection_name = self.collection_name(collection);
        self.vector_store_provider.delete_collection(&collection_name).await
    }

    async fn stats(&self) -> Result<RepositoryStats> {
        // Get stats from vector store if available
        let store_stats = self.vector_store_provider
            .get_stats("default")
            .await
            .unwrap_or_default();

        Ok(RepositoryStats {
            total_chunks: store_stats.get("total_vectors").and_then(|v| v.as_u64()).unwrap_or(0),
            total_collections: 1, // Simplified
            storage_size_bytes: store_stats.get("storage_size_bytes").and_then(|v| v.as_u64()).unwrap_or(0),
            avg_chunk_size_bytes: store_stats.get("avg_vector_size_bytes").and_then(|v| v.as_f64()).unwrap_or(0.0),
        })
    }
}

impl<E, V> VectorStoreChunkRepository<E, V>
where
    E: EmbeddingProvider + Send + Sync,
    V: VectorStoreProvider + Send + Sync,
{
    // Implementation continues...
    /// Validate chunk data before operations
    pub fn validate_chunk(&self, chunk: &CodeChunk) -> Result<()> {
        if chunk.content.is_empty() {
            return Err(Error::validation("Chunk content cannot be empty"));
        }

        if chunk.content.len() > 10000 { // Reasonable limit
            return Err(Error::validation("Chunk content too large (>10KB)"));
        }

        if chunk.file_path.is_empty() {
            return Err(Error::validation("File path cannot be empty"));
        }

        if chunk.start_line == 0 || chunk.end_line == 0 {
            return Err(Error::validation("Line numbers must be positive"));
        }

        if chunk.start_line > chunk.end_line {
            return Err(Error::validation("Start line cannot be greater than end line"));
        }

        Ok(())
    }

    /// Validate collection name
    pub fn validate_collection_name(&self, collection: &str) -> Result<()> {
        if collection.is_empty() {
            return Err(Error::validation("Collection name cannot be empty"));
        }

        if collection.len() > 100 {
            return Err(Error::validation("Collection name too long (>100 chars)"));
        }

        // Check for invalid characters
        if collection.chars().any(|c| !c.is_alphanumeric() && c != '_' && c != '-') {
            return Err(Error::validation("Collection name contains invalid characters"));
        }

        Ok(())
    }
}